# Решение задач восстановления функции
## Описание задач
При передаче сигнала для уменьшения объема передаваемой информации часть её сокращается. Полученные дискретные данные пересылаются получателю через канал связи. Получателю она необходима в полном объеме. Задача состоит в восстановлении исходной функции по полученному набору данных.
- **Исходная информация**: Набор переданных по каналу связи значений \((x, y)\), где \( y \) – значения некоторой неизвестной функции, \( y = f(x) \).
### Задача 1
**Вычислить значение \( y \) для заданного \( x \) (x необязательно одно из значений из исходного набора).**
### Задача 2
**Восстановить аналитический вид исходной функции и вычислить значение \( y \) для заданного \( x \) (x необязательно одно из значений из исходного набора).**
## Решение задач
### Задача 1: Вычисление значения \( y \) для заданного \( x \)
Для решения первой задачи используем интерполяцию. Интерполяция позволяет вычислить значения \( y \) для любых значений \( x \) на основе известных точек.
#### Код
```python
import pandas as pd # Импортирование библиотеки пандас, для работы с табличными данными
import numpy as np # Импортирование библиотеки для работы с массивами
from scipy.interpolate import interp1d # Импортирование функции для интерполяции данных
import matplotlib.pyplot as plt # Импортирование библиотеки для вывода график
def main(points, task, out): # Создание функции с тремя аргументами
    # Загружаем данные
    p = pd.read_csv(points)
    t = pd.read_csv(task)
    # Извлекаем данные в виде массивов 
    x = p['x'].values
    y = p['y'].values
    # Используется функция interp1d для создания интерполяционной функции на основе известных точек
    func = interp1d(x, y, kind='linear', fill_value="extrapolate")
    t['y'] = func(t['x']) # Вычисление значений для у
    # Сохранение результатов
    t[['x', 'y']].to_csv(out, index=False)
    # Вывод графика и результатов
    plt.figure(figsize=(12, 6))
    # Данные для графика
    plt.scatter(x, y, color='blue', label='Исходные данные')
    # Интерполированная функция
    x_i = np.linspace(min(x), max(x), 400)
    y_i = func(x_i)
    plt.plot(x_i, y_i, color='red', label='Интерполированная функция, полученная с использованием линейной интерполяции.')
    # Добавляем подписи для графика
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('График линейной интерполяционной функции')
    plt.legend()
    # Выводим график
    plt.show()
# Вызываем функцию
main('points.csv', 'task.csv', 'results.csv')
```
### Задача 1:
Для решения второй задачи используем полиномиальную аппроксимацию. Полиномиальная аппроксимация позволяет получить аналитическое выражение функции в виде полинома, который можно использовать для вычисления значений ( y ) для любых значений ( x ).
```python
import pandas as pd
import numpy as np
from numpy.polynomial import Polynomial
import matplotlib.pyplot as plt
def main(points, task, out):
    p = pd.read_csv(points)
    t = pd.read_csv(task)
    # Извлечение данных
    x = p['x'].values
    y = p['y'].values
    # Аппроксимация полиномом третьей степени
    c = Polynomial.fit(x, y, 3).convert().coef
    func = np.poly1d(c)
    # Вычисление значений y для x из task
    t['y_p'] = func(t['x'])
    # Сохранение результатов
    t[['x', 'y_p']].to_csv(out, index=False)
    plt.figure(figsize=(12, 6))
    plt.scatter(x, y, color='blue', label='Исходные данные')
    x_poly = np.linspace(min(x), max(x), 400)
    y_poly = func(x_poly)
    plt.plot(x_poly, y_poly, color='green', linestyle='--', label='Полиномиальная аппроксимация, полученная с использованием полинома третьей степени')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('График полиномиальной аппроксимации функции')
    plt.legend()
    plt.show()
main('points.csv', 'task.csv', 'p_results.csv')
```

